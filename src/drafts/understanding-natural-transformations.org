#+STARTUP: showall
#+STARTUP: hidestars
#+OPTIONS: H:2 num:nil tags:nil toc:nil timestamps:t
#+LAYOUT: post
#+AUTHOR: Brendan Good
#+DATE: 2018-04-11 Wed 19:44
#+TITLE: Understanding Natural Transformations
#+DESCRIPTION: Natural transformations are critical in understanding category theory, here I'll explain them as I understand them
#+TAGS: category theory,natural transformations
#+CATEGORIES: math,category theory
#+LATEX_HEADER: \usepackage{amsfonts}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{amscd}

Natural transformations are the gatekeeper to the rest of category theory. Once you understand them, adjoint functors and even the (in)famous monads unveil themselves. In fact,
the "correct" notion of two categories being equivalent (unsurprisingly called an [[https://en.wikipedia.org/wiki/Equivalence_of_categories][equivalence of categories]]) relies on natural transformations.

Despite this notion being critical, I've only really heard two explanations of them (both unenlightening):
- "coordinate free transformations" (what does that even mean)
- "homomorphism of functors" (a bit too high-level to make sense "out of the box")
As is often the case for me, the best approach for me was stare at the diagram and figure out the intuition for myself.

In this post, I'll talk about my intuition for natural transformations and, roughly, how I came to it. Although the understanding I ultimately arrived at is pretty much identical
to the "homomorphism of functors" viewpoint, this posts unwinds that analogy a bit more.

* What is a homomorphism, really?
At its core, a homomorphism is just a map which preserves the structure of its argument. For example, a group homomorphism is a map which sends groups to groups,
a "category homomorphism" (functor) sends categories to categories, etc.

With that in mind, what is the structure of a functor? It's a strange question with a straightforward answer: you apply it. You give me an object from category $C$,
I'll give you an object from category $D$. Similarly, you give me a morphism from $C$, I'll give you a morphism from $D$.

Before we go diving into the intuition, here's the definition of a natural transformation (which is a 90 degree rotation from the one [[https://en.wikipedia.org/wiki/Natural_transformation#Definition][listed on Wikipedia]]).

A natural transformation between two functors $F,G:C\to D$ associates to each object $X\in ob(C)$[fn:1] a morphism $\eta_X: F(X)\to G(X)$ such that the following diagram commutes.
\[\begin{CD}
F(X) @>\eta_X>> G(X) \\
@VF(f)VV        @VVG(f)V \\
F(Y) @>\eta_Y>> G(Y)
\end{CD} \]
Where $f\in mor(X,Y)$[fn:1]

How does this show those properties I said earlier? If I have a functor $F$, I can apply it to an object $X$ and get an object from $D$, the top arrow says that you can take that
object $F(X)$ and get another object $G(X)$ from $D$. The bottom arrow is the same story. So, we have the object part down. If I have some object $F(X)\in ob(D)$[fn:2] via $F$ (call it $F(X)$),
I can get some object from $G(X)\in ob(D)$ via $G$ as well.

Now what about morphisms being preserved? If we stop here, with only mappings of objects, we have the following diagram:

\[\begin{CD}
F(X) @>\eta_X>> G(X) \\
@VF(f)VV        @. \\
F(Y) @>\eta_Y>> G(Y)
\end{CD} \]

This could put is in an uncomfortable situation where we map to objects $G(X)$ and $G(Y)$ that have no morphisms between them. The arrow on the right says that we need to have a morphism in $D$
from the derived object $G(X)$ to the derived object $G(Y)$.

* An odd example that helped it click for me
At a Haskell meetup, the organizer ([[https://gbaz.github.io/][Gershom Bazerman]]) said "When people ask me for references on category theory, I say 'you always learn category theory from the second book you end up reading'",
and I suspect that there may be an element of that here. Nonetheless, even though the example I'm about to provide is not a natural transformation, it helped me further understand
"structure preserving functions".


** Chain complexes

A chain complex $C_\bullet$ (or just $C$) is a collection of $R-\text{modules}$[fn:3] $C_i$ along with module homomorphisms $d_i: C_i\to C_{i-1}$ such that $d_{i-1}\circ d_{i} = 0$

\[\begin{CD}
... @>d_{n+2}>> C_{n+1} @>d_{n+1}>> C_n @>d_n>> C_{n-1} @>d_{n-1}>> ...\\
\end{CD}\]

In particular, note that the kernel of $d_{i-1}$ is a submodule of the image of $d_i$ (since $d_{i-1}\circ d_{i} = 0$), one of the things that we're interested in when we study chain complexes
 is the kernel of $d_{i-1}$ (called cycles) and the image of $d_i$ (called boundaries). In particular, we care about how much bigger the kernel is than the image; in other words,
we want to know the extent to which this diagram is not exact.

From now on, I'll simply refer to the morphisms $d_i$ as simply $d$.
** Morphisms of chain complexes

A morphism of chain complexes from $C_\bullet \to D_\bullet$ is a collection of morphisms $u_i: C_i\to D_i$ such that the following diagram commutes:

\[\begin{CD}
... @>d>> C_{n+1} @>d>> C_n @>d>> C_{n-1} @>d>> ...\\
@.        @Vu_{n+1}VV   @Vu_nVV     @Vu_{n-1}VV\\
... @>d>> D_{n+1} @>d>> D_n @>d>> D_{n-1} @>d>> ...
\end{CD}\]

It can be proven via [[https://en.wikipedia.org/wiki/Five_lemma#Proof][diagram chasing]] that $u$ sends cycles to cycles and boundaries to boundaries, which is to say, chain complex morphisms preserve precisely the structure that we're interested in.

Even though natural transformations may be intimidating at first, it is simply a way to say that two functors have the same structure; I hope this explanation has been helpful!

[fn:1] Here I take $ob(C)$ to mean the objects of the category $C$.
[fn:2] Here I take $mor(X,Y)$ to mean the morphisms between the objects $X$ and $Y$ in the category $C$
[fn:3] If you aren't familiar with modules, replace all instances with "R-module" with "vector space".
