---
date: 2018-04-11
tags:
- category theory
- natural transformations
author: Brendan Good
layout: post
title: Understanding Natural Transformations
excerpt: Natural transformations are critical in understanding category theory, here I'll explain them as I understand them
categories:
- math
- category theory
latex_header: \usepackage{amscd}
---
<p>
Natural transformations are the gatekeeper to the rest of category theory. Once you understand them, adjoint functors and even the (in)famous monads unveil themselves. In fact,
the "correct" notion of two categories being equivalent (unsurprisingly called an <a href="https://en.wikipedia.org/wiki/Equivalence_of_categories">equivalence of categories</a>) relies on natural transformations.
</p>

<p>
Despite this notion being critical, I've only really heard two explanations of them (both unenlightening):
</p>
<ul class="org-ul">
<li>A natural transformations are "coordinate free transformations" (what does that even mean)</li>
<li>A natural transformation is a "homomorphism of functors" (a bit too high-level to make sense "out of the box")</li>
</ul>
<p>
As is often the case for me, the best approach for me was stare at the diagram and figure out the intuition for myself.
</p>

<p>
In this post, I'll talk about my intuition for natural transformations and, roughly, how I came to it. Although the understanding I ultimately arrived at is pretty much identical
to the "homomorphism of functors" viewpoint, this post unwinds that analogy a bit more.
</p>

<div id="outline-container-orgf5b294b" class="outline-2">
<h2 id="orgf5b294b">What is a homomorphism, really?</h2>
<div class="outline-text-2" id="text-orgf5b294b">
<p>
At its core, a homomorphism is just a map which preserves the structure of its argument. For example, a group homomorphism is a map which sends groups to groups,
a "category homomorphism" (functor) sends categories to categories, etc. In fact, in a general category \(C\), if, for two objects \(X,Y\in ob(C)\)<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>, there is a morphism \(f:X\to Y\) this
means that \(Y\) has the same structure as \(X\). Even though that last point sounds like a needless abstraction, that insight will be useful later.
</p>

<p>
With that in mind, what is the structure of a functor? It's a strange question with a straightforward answer: you apply it. You give me an object from a category \(C\),
I'll give you an object from category a \(D\). Similarly, you give me a morphism from \(C\), I'll give you a morphism from \(D\).
</p>
</div>
</div>

<div id="outline-container-org5a00d51" class="outline-2">
<h2 id="org5a00d51">Structure of morphisms</h2>
<div class="outline-text-2" id="text-org5a00d51">
<p>
Before we get into natural transformations, it will be useful to discuss when we consider two morphisms to have the same structure. Consider two morphisms in a category \(C\),
\(f: X\to Y\) and \(g: Z\to W\). What is a reasonable criterion to say that \(g\) has the same structure as \(f\)? A morphism consists of 2 things, a domain and a codomain.
</p>

<p>
Recall that in a category \(C\), object \(Y\) "has the same structure" as \(X\) if there exists a morphism \(f: X\to Y\). With that in mind, we might say that a reasonable definition would
be that two morphisms have the same structure such that the domains and the codomains have the same structure. In other words, we want a diagram that looks like this (not necessarily
commutative):
</p>

<p>
\[\begin{CD}
X    @>j>> Z \\
@VfVV      @VVgV \\
Y    @>k>> W
\end{CD}\\
\\
\begin{center}\textbf{Diagram A}\end{center}\]
</p>

<p>
I want to re-emphasize that, at this point, we do <b>not</b> require that this diagram be commutative (that is do say \(j\circ g\) does not necessarily equal \(f\circ k\)).
</p>

<p>
This looks fine at first glance, since we have that the domain and the codomain have the same structure, but consider the following (silly) example:
</p>

<p>
\[\begin{CD}
\mathbb{Z}              @>x\mapsto x>> \mathbb{Z} \\
@Vx\mapsto x\mod 2VV                   @VVx\mapsto x\mod 3V \\
\mathbb{Z}/ 2\mathbb{Z} @>0>>          \mathbb{Z}/ 3\mathbb{Z}
\end{CD} \]
</p>

<p>
If we compose the top arrow with the right arrow, we get the morphism \(x\mapsto x\mod 3\). However, when we compose the left arrow with the bottom arrow, we get the morphism \(x\mapsto 0\).
Because these resulting morphisms are different, it is possible to recover whether we mapped over via the domain or the codomain depending on what the resulting morphism is.
This seems to indicate that the domain and codomain somehow have a different structure.
</p>

<p>
That is to say, we want to map from either the domain or the codomain and achieve the same morphism. Therefore, we say that \(g\) has the same structure as \(f\) if diagram A (above) is commutative.
</p>
</div>
</div>

<div id="outline-container-org9eacfdf" class="outline-2">
<h2 id="org9eacfdf">Natural transformations</h2>
<div class="outline-text-2" id="text-org9eacfdf">
</div>
<div id="outline-container-orgd8694b4" class="outline-3">
<h3 id="orgd8694b4">The definition</h3>
<div class="outline-text-3" id="text-orgd8694b4">
<p>
A natural transformation between two functors \(F,G:C\to D\) associates to each object \(X\in ob(C)\) a morphism \(\eta_X: F(X)\to G(X)\) such that the following diagram
commutes (which is a 90 degree rotation from the one <a href="https://en.wikipedia.org/wiki/Natural_transformation#Definition">listed on Wikipedia</a>).
\[\begin{CD}
F(X) @>\eta_X>> G(X) \\
@VF(f)VV        @VVG(f)V \\
F(Y) @>\eta_Y>> G(Y)
\end{CD} \]
Where \(f\in mor(X,Y)\)<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>
</p>
</div>
</div>

<div id="outline-container-orgb021111" class="outline-3">
<h3 id="orgb021111">The intuition</h3>
<div class="outline-text-3" id="text-orgb021111">
<p>
How does this construction have those properties I talked about earlier? If I have two functors \(F\) and \(G\), I can apply it them to an object \(X\) and get two objects from \(D\), the top arrow says that
we require a morphism from \(\eta_X:F(X)\to G(X)\), which is to say that we need \(F(X)\) and \(G(X)\) to have the same structure (whatever that means in our particular category).
</p>

<p>
It's worth pointing out that our choice of \(X\) is arbitrary; it could have been any object in \(ob(C)\), so do we really need to specify the bottom arrow since we already have a mapping of
arbitrary objects?
</p>

<p>
Consider the following (silly) example for groups. Here I take \(F,G:Grp\to Grp\) to be the identity functors. I take \(\eta_\mathbb{Z}\) to be the identity function but I take
\(\eta_{\mathbb{Z}/2\mathbb{Z}}\) to be the zero function. If we didn't specify the bottom arrow, the resulting non-commutative diagram would represent a natural transformation.
</p>

<p>
\[\begin{CD}
\mathbb{Z}                   @>x\mapsto x>> \mathbb{Z} \\
@Vx\mapsto x\mod 2VV                        @VVx\mapsto x\mod 2V \\
\mathbb{Z}/ 2\mathbb{Z} @>0>>          \mathbb{Z}/ 2\mathbb{Z}
\end{CD} \]
</p>

<p>
Explicitly stating that the bottom arrow makes the diagram commute is surprisingly deep. The bottom arrow is the condition that our functors change morphisms and objects in a way that are
compatible with each other! Something is the same regardless of whether you started in the domain or codomain.
</p>
</div>
</div>
</div>

<div id="outline-container-org07ee7a1" class="outline-2">
<h2 id="org07ee7a1">An odd example that helped it click for me</h2>
<div class="outline-text-2" id="text-org07ee7a1">
<p>
At a Haskell meetup, the organizer (<a href="https://gbaz.github.io/">Gershom Bazerman</a>) said "When people ask me for references on category theory, I say 'you always learn category theory from the second book you end up reading'",
and I suspect that there may be an element of that here. Nonetheless, even though the example I'm about to provide is not a natural transformation, it helped me further understand
"structure preserving functions".
</p>
</div>


<div id="outline-container-org62a86c1" class="outline-3">
<h3 id="org62a86c1">Chain complexes</h3>
<div class="outline-text-3" id="text-org62a86c1">
<p>
A chain complex \(C_\bullet\) (or just \(C\)) is a collection of \(R-\text{modules}\)<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup> \(C_i\) along with module homomorphisms \(d_i: C_i\to C_{i-1}\) such that \(d_{i-1}\circ d_{i} = 0\)
</p>

<p>
\[\begin{CD}
... @>d_{n+2}>> C_{n+1} @>d_{n+1}>> C_n @>d_n>> C_{n-1} @>d_{n-1}>> ...\\
\end{CD}\]
</p>

<p>
In particular, note that the kernel of \(d_{i-1}\) is a submodule of the image of \(d_i\) (since \(d_{i-1}\circ d_{i} = 0\)), one of the things that we're interested in when we study chain complexes
 is the kernel of \(d_{i-1}\) (called cycles) and the image of \(d_i\) (called boundaries). In particular, we care about how much bigger the kernel is than the image; in other words,
we want to know the extent to which this diagram is not exact.
</p>

<p>
From now on, I'll simply refer to the morphisms \(d_i\) as simply \(d\).
</p>
</div>
</div>
<div id="outline-container-org8432e8e" class="outline-3">
<h3 id="org8432e8e">Morphisms of chain complexes</h3>
<div class="outline-text-3" id="text-org8432e8e">
<p>
A morphism of chain complexes from \(C_\bullet \to D_\bullet\) is a collection of morphisms \(u_i: C_i\to D_i\) such that the following diagram commutes:
</p>

<p>
\[\begin{CD}
... @>d>> C_{n+1} @>d>> C_n @>d>> C_{n-1} @>d>> ...\\
@.        @Vu_{n+1}VV   @Vu_nVV     @Vu_{n-1}VV\\
... @>d>> D_{n+1} @>d>> D_n @>d>> D_{n-1} @>d>> ...
\end{CD}\]
</p>

<p>
It can be proven via <a href="https://en.wikipedia.org/wiki/Five_lemma#Proof">diagram chasing</a> that \(u\) sends cycles to cycles and boundaries to boundaries, which is to say, chain complex morphisms preserve precisely the structure that we're interested in.
</p>

<p>
Even though natural transformations may be intimidating at first, it is simply a way to say that two functors have the same structure; I hope this explanation has been helpful!
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Here I take \(ob(C)\) to mean the objects of the category \(C\).
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
Here I take \(mor(X,Y)\) to mean the morphisms between the objects \(X\) and \(Y\) in the category \(C\).
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
If you aren't familiar with modules, replace all instances with "R-module" with "vector space" or "abelian group".
</p></div></div>


</div>
</div>
